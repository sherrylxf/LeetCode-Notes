# 位运算

## 1. 与、或、异或和取反
- **与运算 (`&`)**: 对应位都为 1 时，结果才为 1，否则为 0。
- **或运算 (`|`)**: 对应位有一个为 1 时，结果为 1，否则为 0。
- **异或运算 (`^`)**: 对应位相同为 0，不同为 1。
- **取反运算 (`~`)**: 将二进制的每一位反转，0 变 1，1 变 0。

## 2. 移位运算
- **左移 (`<<`)**: 高位丢弃，低位补 0。
- **右移 (`>>`)**: 
  - 算术移位：高位补符号位，低位丢弃。
  - 逻辑移位：高位补 0，低位丢弃。

## 3. 位运算的性质
- **取反运算性质**：
  - `-a = ~(a - 1)`。这是因为取反后的数加 1 等于负数的补码。
- **`a & (a - 1)`**: 将 `a` 的二进制表示中的最后一个 1 变为 0。
- **`a & (-a)`**: 只保留二进制表示中的最后一个 1，其余的变为 0。

---

# 例题解析
## 1. 十进制转七进制
```cpp
class Solution {
public:
    string convertToBase7(int num) {
        if (num == 0) return "0";  // 特殊情况处理，0 的七进制表示是 "0"
        
        bool isNegative = num < 0;  // 判断是否为负数
        num = abs(num);  // 转换为正数进行处理
        
        string s = "";
        while (num > 0) {
            s = to_string(num % 7) + s;  // 计算当前位的数字并加到字符串前面
            num /= 7;  // 去掉最后一位
        }
        
        if (isNegative) s = "-" + s;  // 如果是负数，添加负号
        
        return s;
    }
};
```
## 2.	十进制转十六进制（补码方式）
```cpp
class Solution {
public:
    string toHex(int num) {
        if (num == 0) return "0"; // 特殊情况处理，0的十六进制表示是"0"
        
        string hex_chars = "0123456789abcdef";  // 十六进制字符集
        string s = "";
        
        // 补码表示，负数会以32位补码形式表示
        unsigned int n = num;  // 将整数转换为无符号数以处理负数
        while (n > 0) {
            s = hex_chars[n & 0xF] + s;  // 提取最低4位，并拼接到字符串前面
            n >>= 4;  // 右移4位，处理下一位
        }
        
        return s;
    }
};
```
## 3.	给定一个正整数 n，编写一个函数，获取一个正整数的二进制形式，并返回其二进制表达式中设置位的个数。
- 输入：n = 11
- 输出：3
- 解释：输入的二进制串 1011 中，共有 3 个设置位。
```cpp
class Solution {
public:
    int hammingWeight(int n) {
        int count=0;
        while(n!=0){
            n=n&(n-1); //利用位运算的性质
            count++;
        }
        return count;
    }
};
```
## 4. 颠倒给定的 32 位无符号整数的二进制位。
```cpp
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        uint32_t num=0;
        int x=31;
        while(n!=0){
            num+=(n&1)<<x;
            n>>=1;
            x--;
        }
        return num;
    }
};
```
## 5. 两整数之和（不用 + ）
- 加法的结果分成两个部分，分别是进位部分和非进位部分。
- 进位部分：只有当两个数都是1时，才会发生进位，进位部分的值是10，因此进位部分可以看成是两个数的按位与的结果左移一位。
- 非进位部分：当两个数相同时非进位部分的值是0，当两个数不同时非进位部分的值是1，因此非进位部分可以看成是两个数的按位异或的结果。
```cpp
class Solution {
public:
    int getSum(int a, int b) {
        while(a!=0){
            int temp=a^b;
            a=(a&b)<<1;
            b=temp;
        }
        return b;
    }
};
```